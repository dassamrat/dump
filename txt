import requests
import base64
import json
import csv

WIZ_CLIENT_ID = ""
WIZ_CLIENT_SECRET = ""
WIZ_AUDIENCE = "wiz-api"
WIZ_AUTH_URL = "https://auth.app.wiz.io/oauth/token"

QUERY = """
query WorkloadScanLogTable($first: Int, $after: String, $filterBy: ResourceScanResultFilters, $orderBy: ResourceScanResultsOrder, $projectId: [String!]) {
  resourceScanResults(
    first: $first
    after: $after
    filterBy: $filterBy
    orderBy: $orderBy
    projectId: $projectId
  ) {
    nodes {
      id
      status
      statusMessage
      triggerType
      triggerSource
      timestamp
      projects {
        id
        name
        slug
        isFolder
      }
      connector {
        id
        name
        type {
          id
          name
        }
      }
      resource {
        region
        graphEntity {
          id
          type
          name
          properties
        }
      }
      outpost {
        id
        name
        serviceType
      }
      cluster {
        id
        serviceType
        config {
          ... on OutpostClusterAWSConfig {
            clusterName
          }
          ... on OutpostClusterAlibabaConfig {
            clusterName
          }
          ... on OutpostClusterAzureConfig {
            clusterName
          }
          ... on OutpostClusterGCPConfig {
            clusterName
          }
          ... on OutpostClusterLiteConfig {
            clusterName
          }
          ... on OutpostClusterOCIConfig {
            clusterName
          }
        }
      }
    }
    pageInfo {
      hasNextPage
      endCursor
    }
    maxCountReached
    totalCount
  }
}
"""

VARIABLES = {
  "first": 20,
  "filterBy": {
    "resource": {},
    "modules": {},
    "status": {
      "equals": [
        "SUCCESS",
        "FAILED"
      ]
    }
  },
  "orderBy": {
    "field": "TIMESTAMP",
    "direction": "DESC"
  },
  "projectId": None
}

def get_access_token():
    payload = {
        "client_id": WIZ_CLIENT_ID,
        "client_secret": WIZ_CLIENT_SECRET,
        "audience": WIZ_AUDIENCE,
        "grant_type": "client_credentials"
    }
    headers = {
        "accept": "application/json",
        "Content-Type": "application/x-www-form-urlencoded"
    }
    resp = requests.post(WIZ_AUTH_URL, data=payload, headers=headers)
    resp.raise_for_status()
    return resp.json()["access_token"]

def extract_dc_from_token(token):
    payload_part = token.split(".")[1]
    padded = payload_part + "=" * (-len(payload_part) % 4)
    decoded_bytes = base64.urlsafe_b64decode(padded)
    claims = json.loads(decoded_bytes)
    return claims.get("dc", "unknown")

def get_api_url(dc):
    return f"https://api.{dc}.app.wiz.io/graphql"

def run_graphql_query(token, api_url, query, variables=None, operation_name=None):
    headers = {
        "Authorization": f"Bearer {token}",
        "Content-Type": "application/json"
    }
    body = {
        "query": query,
        "variables": variables or {}
    }
    if operation_name:
        body["operationName"] = operation_name
    response = requests.post(api_url, json=body, headers=headers)
    response.raise_for_status()
    return response.json()

def flatten_node(node):
    return {
        "id": node.get("id"),
        "status": node.get("status"),
        "statusMessage": node.get("statusMessage"),
        "triggerType": node.get("triggerType"),
        "triggerSource": node.get("triggerSource"),
        "timestamp": node.get("timestamp"),
        "projects": ";".join([p.get("name") for p in node.get("projects")]) if node.get("projects") else "",
        "connector_id": node.get("connector", {}).get("id"),
        "connector_name": node.get("connector", {}).get("name"),
        "connector_type_id": node.get("connector", {}).get("type", {}).get("id"),
        "connector_type_name": node.get("connector", {}).get("type", {}).get("name"),
        "resource_region": node.get("resource", {}).get("region"),
        "resource_graphEntity_id": node.get("resource", {}).get("graphEntity", {}).get("id"),
        "resource_graphEntity_type": node.get("resource", {}).get("graphEntity", {}).get("type"),
        "resource_graphEntity_name": node.get("resource", {}).get("graphEntity", {}).get("name"),
        "resource_graphEntity_properties": json.dumps(node.get("resource", {}).get("graphEntity", {}).get("properties")),
        "outpost_id": node.get("outpost", {}).get("id") if node.get("outpost") else None,
        "outpost_name": node.get("outpost", {}).get("name") if node.get("outpost") else None,
        "outpost_serviceType": node.get("outpost", {}).get("serviceType") if node.get("outpost") else None,
        "cluster_id": node.get("cluster", {}).get("id") if node.get("cluster") else None,
        "cluster_serviceType": node.get("cluster", {}).get("serviceType") if node.get("cluster") else None,
        "cluster_config_clusterName": None
    }

def extract_cluster_config_clusterName(cluster):
    if not cluster or "config" not in cluster or not cluster["config"]:
        return None
    config = cluster["config"]
    # The cluster config is a union type with one of the specific types having clusterName
    for key in config:
        val = config[key]
        if val and "clusterName" in val:
            return val["clusterName"]
    return None

if __name__ == "__main__":
    token = get_access_token()
    dc = extract_dc_from_token(token)
    api_url = get_api_url(dc)

    all_nodes = []
    has_next_page = True
    after_cursor = None
    VARIABLES["first"] = 50  # for more efficient pagination

    while has_next_page:
        VARIABLES["after"] = after_cursor
        result = run_graphql_query(token, api_url, QUERY, VARIABLES, operation_name="WorkloadScanLogTable")
        data = result.get("data", {}).get("resourceScanResults", {})
        nodes = data.get("nodes", [])
        for node in nodes:
            flat = flatten_node(node)
            flat["cluster_config_clusterName"] = extract_cluster_config_clusterName(node.get("cluster"))
            all_nodes.append(flat)
        page_info = data.get("pageInfo", {})
        has_next_page = page_info.get("hasNextPage", False)
        after_cursor = page_info.get("endCursor")

    if all_nodes:
        with open("workload_scan_status.csv", "w", encoding="utf-8", newline="") as f:
            writer = csv.DictWriter(f, fieldnames=all_nodes[0].keys())
            writer.writeheader()
            writer.writerows(all_nodes)

    print(f"Wrote {len(all_nodes)} workload scan records to workload_scan_status.csv")
